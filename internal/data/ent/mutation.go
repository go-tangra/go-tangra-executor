// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/go-tangra/go-tangra-executor/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-executor/internal/data/ent/executionlog"
	"github.com/go-tangra/go-tangra-executor/internal/data/ent/predicate"
	"github.com/go-tangra/go-tangra-executor/internal/data/ent/script"
	"github.com/go-tangra/go-tangra-executor/internal/data/ent/scriptassignment"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog         = "AuditLog"
	TypeExecutionLog     = "ExecutionLog"
	TypeScript           = "Script"
	TypeScriptAssignment = "ScriptAssignment"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	create_time          *time.Time
	update_time          *time.Time
	delete_time          *time.Time
	tenant_id            *uint32
	addtenant_id         *int32
	audit_id             *string
	request_id           *string
	operation            *string
	service_name         *string
	client_id            *string
	client_common_name   *string
	client_organization  *string
	client_serial_number *string
	is_authenticated     *bool
	success              *bool
	error_code           *int32
	adderror_code        *int32
	error_message        *string
	latency_ms           *int64
	addlatency_ms        *int64
	peer_address         *string
	geo_location         *map[string]string
	log_hash             *string
	signature            *[]byte
	metadata             *map[string]string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AuditLog, error)
	predicates           []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uint32) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AuditLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AuditLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AuditLogMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[auditlog.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AuditLogMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AuditLogMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, auditlog.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AuditLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AuditLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AuditLogMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[auditlog.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AuditLogMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AuditLogMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, auditlog.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *AuditLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AuditLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AuditLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[auditlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AuditLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AuditLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, auditlog.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetAuditID sets the "audit_id" field.
func (m *AuditLogMutation) SetAuditID(s string) {
	m.audit_id = &s
}

// AuditID returns the value of the "audit_id" field in the mutation.
func (m *AuditLogMutation) AuditID() (r string, exists bool) {
	v := m.audit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditID returns the old "audit_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAuditID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditID: %w", err)
	}
	return oldValue.AuditID, nil
}

// ResetAuditID resets all changes to the "audit_id" field.
func (m *AuditLogMutation) ResetAuditID() {
	m.audit_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
}

// SetServiceName sets the "service_name" field.
func (m *AuditLogMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *AuditLogMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *AuditLogMutation) ResetServiceName() {
	m.service_name = nil
}

// SetClientID sets the "client_id" field.
func (m *AuditLogMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuditLogMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *AuditLogMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[auditlog.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *AuditLogMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuditLogMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, auditlog.FieldClientID)
}

// SetClientCommonName sets the "client_common_name" field.
func (m *AuditLogMutation) SetClientCommonName(s string) {
	m.client_common_name = &s
}

// ClientCommonName returns the value of the "client_common_name" field in the mutation.
func (m *AuditLogMutation) ClientCommonName() (r string, exists bool) {
	v := m.client_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCommonName returns the old "client_common_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCommonName: %w", err)
	}
	return oldValue.ClientCommonName, nil
}

// ClearClientCommonName clears the value of the "client_common_name" field.
func (m *AuditLogMutation) ClearClientCommonName() {
	m.client_common_name = nil
	m.clearedFields[auditlog.FieldClientCommonName] = struct{}{}
}

// ClientCommonNameCleared returns if the "client_common_name" field was cleared in this mutation.
func (m *AuditLogMutation) ClientCommonNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientCommonName]
	return ok
}

// ResetClientCommonName resets all changes to the "client_common_name" field.
func (m *AuditLogMutation) ResetClientCommonName() {
	m.client_common_name = nil
	delete(m.clearedFields, auditlog.FieldClientCommonName)
}

// SetClientOrganization sets the "client_organization" field.
func (m *AuditLogMutation) SetClientOrganization(s string) {
	m.client_organization = &s
}

// ClientOrganization returns the value of the "client_organization" field in the mutation.
func (m *AuditLogMutation) ClientOrganization() (r string, exists bool) {
	v := m.client_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOrganization returns the old "client_organization" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOrganization: %w", err)
	}
	return oldValue.ClientOrganization, nil
}

// ClearClientOrganization clears the value of the "client_organization" field.
func (m *AuditLogMutation) ClearClientOrganization() {
	m.client_organization = nil
	m.clearedFields[auditlog.FieldClientOrganization] = struct{}{}
}

// ClientOrganizationCleared returns if the "client_organization" field was cleared in this mutation.
func (m *AuditLogMutation) ClientOrganizationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientOrganization]
	return ok
}

// ResetClientOrganization resets all changes to the "client_organization" field.
func (m *AuditLogMutation) ResetClientOrganization() {
	m.client_organization = nil
	delete(m.clearedFields, auditlog.FieldClientOrganization)
}

// SetClientSerialNumber sets the "client_serial_number" field.
func (m *AuditLogMutation) SetClientSerialNumber(s string) {
	m.client_serial_number = &s
}

// ClientSerialNumber returns the value of the "client_serial_number" field in the mutation.
func (m *AuditLogMutation) ClientSerialNumber() (r string, exists bool) {
	v := m.client_serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSerialNumber returns the old "client_serial_number" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSerialNumber: %w", err)
	}
	return oldValue.ClientSerialNumber, nil
}

// ClearClientSerialNumber clears the value of the "client_serial_number" field.
func (m *AuditLogMutation) ClearClientSerialNumber() {
	m.client_serial_number = nil
	m.clearedFields[auditlog.FieldClientSerialNumber] = struct{}{}
}

// ClientSerialNumberCleared returns if the "client_serial_number" field was cleared in this mutation.
func (m *AuditLogMutation) ClientSerialNumberCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientSerialNumber]
	return ok
}

// ResetClientSerialNumber resets all changes to the "client_serial_number" field.
func (m *AuditLogMutation) ResetClientSerialNumber() {
	m.client_serial_number = nil
	delete(m.clearedFields, auditlog.FieldClientSerialNumber)
}

// SetIsAuthenticated sets the "is_authenticated" field.
func (m *AuditLogMutation) SetIsAuthenticated(b bool) {
	m.is_authenticated = &b
}

// IsAuthenticated returns the value of the "is_authenticated" field in the mutation.
func (m *AuditLogMutation) IsAuthenticated() (r bool, exists bool) {
	v := m.is_authenticated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAuthenticated returns the old "is_authenticated" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIsAuthenticated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAuthenticated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAuthenticated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAuthenticated: %w", err)
	}
	return oldValue.IsAuthenticated, nil
}

// ResetIsAuthenticated resets all changes to the "is_authenticated" field.
func (m *AuditLogMutation) ResetIsAuthenticated() {
	m.is_authenticated = nil
}

// SetSuccess sets the "success" field.
func (m *AuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *AuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *AuditLogMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorCode sets the "error_code" field.
func (m *AuditLogMutation) SetErrorCode(i int32) {
	m.error_code = &i
	m.adderror_code = nil
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *AuditLogMutation) ErrorCode() (r int32, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorCode(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// AddErrorCode adds i to the "error_code" field.
func (m *AuditLogMutation) AddErrorCode(i int32) {
	if m.adderror_code != nil {
		*m.adderror_code += i
	} else {
		m.adderror_code = &i
	}
}

// AddedErrorCode returns the value that was added to the "error_code" field in this mutation.
func (m *AuditLogMutation) AddedErrorCode() (r int32, exists bool) {
	v := m.adderror_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *AuditLogMutation) ClearErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	m.clearedFields[auditlog.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *AuditLogMutation) ResetErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	delete(m.clearedFields, auditlog.FieldErrorCode)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *AuditLogMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *AuditLogMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *AuditLogMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *AuditLogMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *AuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
}

// SetPeerAddress sets the "peer_address" field.
func (m *AuditLogMutation) SetPeerAddress(s string) {
	m.peer_address = &s
}

// PeerAddress returns the value of the "peer_address" field in the mutation.
func (m *AuditLogMutation) PeerAddress() (r string, exists bool) {
	v := m.peer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerAddress returns the old "peer_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPeerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerAddress: %w", err)
	}
	return oldValue.PeerAddress, nil
}

// ClearPeerAddress clears the value of the "peer_address" field.
func (m *AuditLogMutation) ClearPeerAddress() {
	m.peer_address = nil
	m.clearedFields[auditlog.FieldPeerAddress] = struct{}{}
}

// PeerAddressCleared returns if the "peer_address" field was cleared in this mutation.
func (m *AuditLogMutation) PeerAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPeerAddress]
	return ok
}

// ResetPeerAddress resets all changes to the "peer_address" field.
func (m *AuditLogMutation) ResetPeerAddress() {
	m.peer_address = nil
	delete(m.clearedFields, auditlog.FieldPeerAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *AuditLogMutation) SetGeoLocation(value map[string]string) {
	m.geo_location = &value
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *AuditLogMutation) GeoLocation() (r map[string]string, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldGeoLocation(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *AuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[auditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *AuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *AuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, auditlog.FieldGeoLocation)
}

// SetLogHash sets the "log_hash" field.
func (m *AuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *AuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLogHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *AuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[auditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *AuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *AuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, auditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *AuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *AuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *AuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[auditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *AuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *AuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, auditlog.FieldSignature)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.audit_id != nil {
		fields = append(fields, auditlog.FieldAuditID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.service_name != nil {
		fields = append(fields, auditlog.FieldServiceName)
	}
	if m.client_id != nil {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.client_common_name != nil {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.client_organization != nil {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.client_serial_number != nil {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.is_authenticated != nil {
		fields = append(fields, auditlog.FieldIsAuthenticated)
	}
	if m.success != nil {
		fields = append(fields, auditlog.FieldSuccess)
	}
	if m.error_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.latency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	if m.peer_address != nil {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.log_hash != nil {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.CreateTime()
	case auditlog.FieldUpdateTime:
		return m.UpdateTime()
	case auditlog.FieldDeleteTime:
		return m.DeleteTime()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldAuditID:
		return m.AuditID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldServiceName:
		return m.ServiceName()
	case auditlog.FieldClientID:
		return m.ClientID()
	case auditlog.FieldClientCommonName:
		return m.ClientCommonName()
	case auditlog.FieldClientOrganization:
		return m.ClientOrganization()
	case auditlog.FieldClientSerialNumber:
		return m.ClientSerialNumber()
	case auditlog.FieldIsAuthenticated:
		return m.IsAuthenticated()
	case auditlog.FieldSuccess:
		return m.Success()
	case auditlog.FieldErrorCode:
		return m.ErrorCode()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldLatencyMs:
		return m.LatencyMs()
	case auditlog.FieldPeerAddress:
		return m.PeerAddress()
	case auditlog.FieldGeoLocation:
		return m.GeoLocation()
	case auditlog.FieldLogHash:
		return m.LogHash()
	case auditlog.FieldSignature:
		return m.Signature()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case auditlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case auditlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldAuditID:
		return m.OldAuditID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldServiceName:
		return m.OldServiceName(ctx)
	case auditlog.FieldClientID:
		return m.OldClientID(ctx)
	case auditlog.FieldClientCommonName:
		return m.OldClientCommonName(ctx)
	case auditlog.FieldClientOrganization:
		return m.OldClientOrganization(ctx)
	case auditlog.FieldClientSerialNumber:
		return m.OldClientSerialNumber(ctx)
	case auditlog.FieldIsAuthenticated:
		return m.OldIsAuthenticated(ctx)
	case auditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case auditlog.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case auditlog.FieldPeerAddress:
		return m.OldPeerAddress(ctx)
	case auditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case auditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case auditlog.FieldSignature:
		return m.OldSignature(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case auditlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case auditlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldAuditID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case auditlog.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case auditlog.FieldClientCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCommonName(v)
		return nil
	case auditlog.FieldClientOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOrganization(v)
		return nil
	case auditlog.FieldClientSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSerialNumber(v)
		return nil
	case auditlog.FieldIsAuthenticated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAuthenticated(v)
		return nil
	case auditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case auditlog.FieldPeerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerAddress(v)
		return nil
	case auditlog.FieldGeoLocation:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case auditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case auditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adderror_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldErrorCode:
		return m.AddedErrorCode()
	case auditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCode(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldCreateTime) {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.FieldCleared(auditlog.FieldUpdateTime) {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.FieldCleared(auditlog.FieldDeleteTime) {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldClientID) {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.FieldCleared(auditlog.FieldClientCommonName) {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.FieldCleared(auditlog.FieldClientOrganization) {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.FieldCleared(auditlog.FieldClientSerialNumber) {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.FieldCleared(auditlog.FieldErrorCode) {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldPeerAddress) {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.FieldCleared(auditlog.FieldGeoLocation) {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.FieldCleared(auditlog.FieldLogHash) {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.FieldCleared(auditlog.FieldSignature) {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldClientID:
		m.ClearClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ClearClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ClearClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ClearClientSerialNumber()
		return nil
	case auditlog.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldPeerAddress:
		m.ClearPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ClearSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldAuditID:
		m.ResetAuditID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldServiceName:
		m.ResetServiceName()
		return nil
	case auditlog.FieldClientID:
		m.ResetClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ResetClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ResetClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ResetClientSerialNumber()
		return nil
	case auditlog.FieldIsAuthenticated:
		m.ResetIsAuthenticated()
		return nil
	case auditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case auditlog.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case auditlog.FieldPeerAddress:
		m.ResetPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ResetSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// ExecutionLogMutation represents an operation that mutates the ExecutionLog nodes in the graph.
type ExecutionLogMutation struct {
	config
	op               Op
	typ              string
	id               *string
	create_by        *uint32
	addcreate_by     *int32
	create_time      *time.Time
	update_time      *time.Time
	delete_time      *time.Time
	tenant_id        *uint32
	addtenant_id     *int32
	script_id        *string
	script_name      *string
	client_id        *string
	script_hash      *string
	trigger_type     *executionlog.TriggerType
	status           *executionlog.Status
	exit_code        *int
	addexit_code     *int
	output           *string
	error_output     *string
	rejection_reason *string
	started_at       *time.Time
	completed_at     *time.Time
	duration_ms      *int64
	addduration_ms   *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ExecutionLog, error)
	predicates       []predicate.ExecutionLog
}

var _ ent.Mutation = (*ExecutionLogMutation)(nil)

// executionlogOption allows management of the mutation configuration using functional options.
type executionlogOption func(*ExecutionLogMutation)

// newExecutionLogMutation creates new mutation for the ExecutionLog entity.
func newExecutionLogMutation(c config, op Op, opts ...executionlogOption) *ExecutionLogMutation {
	m := &ExecutionLogMutation{
		config:        c,
		op:            op,
		typ:           TypeExecutionLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExecutionLogID sets the ID field of the mutation.
func withExecutionLogID(id string) executionlogOption {
	return func(m *ExecutionLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ExecutionLog
		)
		m.oldValue = func(ctx context.Context) (*ExecutionLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExecutionLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExecutionLog sets the old ExecutionLog of the mutation.
func withExecutionLog(node *ExecutionLog) executionlogOption {
	return func(m *ExecutionLogMutation) {
		m.oldValue = func(context.Context) (*ExecutionLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExecutionLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExecutionLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExecutionLog entities.
func (m *ExecutionLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExecutionLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExecutionLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExecutionLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *ExecutionLogMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *ExecutionLogMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *ExecutionLogMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *ExecutionLogMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *ExecutionLogMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[executionlog.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *ExecutionLogMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *ExecutionLogMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, executionlog.FieldCreateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *ExecutionLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ExecutionLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ExecutionLogMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[executionlog.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ExecutionLogMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ExecutionLogMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, executionlog.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *ExecutionLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ExecutionLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ExecutionLogMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[executionlog.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ExecutionLogMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ExecutionLogMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, executionlog.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *ExecutionLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ExecutionLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ExecutionLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[executionlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ExecutionLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ExecutionLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, executionlog.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *ExecutionLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ExecutionLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *ExecutionLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ExecutionLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ExecutionLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[executionlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ExecutionLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ExecutionLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, executionlog.FieldTenantID)
}

// SetScriptID sets the "script_id" field.
func (m *ExecutionLogMutation) SetScriptID(s string) {
	m.script_id = &s
}

// ScriptID returns the value of the "script_id" field in the mutation.
func (m *ExecutionLogMutation) ScriptID() (r string, exists bool) {
	v := m.script_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptID returns the old "script_id" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldScriptID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptID: %w", err)
	}
	return oldValue.ScriptID, nil
}

// ResetScriptID resets all changes to the "script_id" field.
func (m *ExecutionLogMutation) ResetScriptID() {
	m.script_id = nil
}

// SetScriptName sets the "script_name" field.
func (m *ExecutionLogMutation) SetScriptName(s string) {
	m.script_name = &s
}

// ScriptName returns the value of the "script_name" field in the mutation.
func (m *ExecutionLogMutation) ScriptName() (r string, exists bool) {
	v := m.script_name
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptName returns the old "script_name" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldScriptName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptName: %w", err)
	}
	return oldValue.ScriptName, nil
}

// ResetScriptName resets all changes to the "script_name" field.
func (m *ExecutionLogMutation) ResetScriptName() {
	m.script_name = nil
}

// SetClientID sets the "client_id" field.
func (m *ExecutionLogMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *ExecutionLogMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *ExecutionLogMutation) ResetClientID() {
	m.client_id = nil
}

// SetScriptHash sets the "script_hash" field.
func (m *ExecutionLogMutation) SetScriptHash(s string) {
	m.script_hash = &s
}

// ScriptHash returns the value of the "script_hash" field in the mutation.
func (m *ExecutionLogMutation) ScriptHash() (r string, exists bool) {
	v := m.script_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptHash returns the old "script_hash" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldScriptHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptHash: %w", err)
	}
	return oldValue.ScriptHash, nil
}

// ResetScriptHash resets all changes to the "script_hash" field.
func (m *ExecutionLogMutation) ResetScriptHash() {
	m.script_hash = nil
}

// SetTriggerType sets the "trigger_type" field.
func (m *ExecutionLogMutation) SetTriggerType(et executionlog.TriggerType) {
	m.trigger_type = &et
}

// TriggerType returns the value of the "trigger_type" field in the mutation.
func (m *ExecutionLogMutation) TriggerType() (r executionlog.TriggerType, exists bool) {
	v := m.trigger_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerType returns the old "trigger_type" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldTriggerType(ctx context.Context) (v executionlog.TriggerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerType: %w", err)
	}
	return oldValue.TriggerType, nil
}

// ResetTriggerType resets all changes to the "trigger_type" field.
func (m *ExecutionLogMutation) ResetTriggerType() {
	m.trigger_type = nil
}

// SetStatus sets the "status" field.
func (m *ExecutionLogMutation) SetStatus(e executionlog.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *ExecutionLogMutation) Status() (r executionlog.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldStatus(ctx context.Context) (v executionlog.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ExecutionLogMutation) ResetStatus() {
	m.status = nil
}

// SetExitCode sets the "exit_code" field.
func (m *ExecutionLogMutation) SetExitCode(i int) {
	m.exit_code = &i
	m.addexit_code = nil
}

// ExitCode returns the value of the "exit_code" field in the mutation.
func (m *ExecutionLogMutation) ExitCode() (r int, exists bool) {
	v := m.exit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldExitCode returns the old "exit_code" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldExitCode(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitCode: %w", err)
	}
	return oldValue.ExitCode, nil
}

// AddExitCode adds i to the "exit_code" field.
func (m *ExecutionLogMutation) AddExitCode(i int) {
	if m.addexit_code != nil {
		*m.addexit_code += i
	} else {
		m.addexit_code = &i
	}
}

// AddedExitCode returns the value that was added to the "exit_code" field in this mutation.
func (m *ExecutionLogMutation) AddedExitCode() (r int, exists bool) {
	v := m.addexit_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearExitCode clears the value of the "exit_code" field.
func (m *ExecutionLogMutation) ClearExitCode() {
	m.exit_code = nil
	m.addexit_code = nil
	m.clearedFields[executionlog.FieldExitCode] = struct{}{}
}

// ExitCodeCleared returns if the "exit_code" field was cleared in this mutation.
func (m *ExecutionLogMutation) ExitCodeCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldExitCode]
	return ok
}

// ResetExitCode resets all changes to the "exit_code" field.
func (m *ExecutionLogMutation) ResetExitCode() {
	m.exit_code = nil
	m.addexit_code = nil
	delete(m.clearedFields, executionlog.FieldExitCode)
}

// SetOutput sets the "output" field.
func (m *ExecutionLogMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *ExecutionLogMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *ExecutionLogMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[executionlog.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *ExecutionLogMutation) OutputCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *ExecutionLogMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, executionlog.FieldOutput)
}

// SetErrorOutput sets the "error_output" field.
func (m *ExecutionLogMutation) SetErrorOutput(s string) {
	m.error_output = &s
}

// ErrorOutput returns the value of the "error_output" field in the mutation.
func (m *ExecutionLogMutation) ErrorOutput() (r string, exists bool) {
	v := m.error_output
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorOutput returns the old "error_output" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldErrorOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorOutput: %w", err)
	}
	return oldValue.ErrorOutput, nil
}

// ClearErrorOutput clears the value of the "error_output" field.
func (m *ExecutionLogMutation) ClearErrorOutput() {
	m.error_output = nil
	m.clearedFields[executionlog.FieldErrorOutput] = struct{}{}
}

// ErrorOutputCleared returns if the "error_output" field was cleared in this mutation.
func (m *ExecutionLogMutation) ErrorOutputCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldErrorOutput]
	return ok
}

// ResetErrorOutput resets all changes to the "error_output" field.
func (m *ExecutionLogMutation) ResetErrorOutput() {
	m.error_output = nil
	delete(m.clearedFields, executionlog.FieldErrorOutput)
}

// SetRejectionReason sets the "rejection_reason" field.
func (m *ExecutionLogMutation) SetRejectionReason(s string) {
	m.rejection_reason = &s
}

// RejectionReason returns the value of the "rejection_reason" field in the mutation.
func (m *ExecutionLogMutation) RejectionReason() (r string, exists bool) {
	v := m.rejection_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectionReason returns the old "rejection_reason" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldRejectionReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectionReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectionReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectionReason: %w", err)
	}
	return oldValue.RejectionReason, nil
}

// ClearRejectionReason clears the value of the "rejection_reason" field.
func (m *ExecutionLogMutation) ClearRejectionReason() {
	m.rejection_reason = nil
	m.clearedFields[executionlog.FieldRejectionReason] = struct{}{}
}

// RejectionReasonCleared returns if the "rejection_reason" field was cleared in this mutation.
func (m *ExecutionLogMutation) RejectionReasonCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldRejectionReason]
	return ok
}

// ResetRejectionReason resets all changes to the "rejection_reason" field.
func (m *ExecutionLogMutation) ResetRejectionReason() {
	m.rejection_reason = nil
	delete(m.clearedFields, executionlog.FieldRejectionReason)
}

// SetStartedAt sets the "started_at" field.
func (m *ExecutionLogMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExecutionLogMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ExecutionLogMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[executionlog.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ExecutionLogMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExecutionLogMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, executionlog.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *ExecutionLogMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ExecutionLogMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ExecutionLogMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[executionlog.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ExecutionLogMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ExecutionLogMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, executionlog.FieldCompletedAt)
}

// SetDurationMs sets the "duration_ms" field.
func (m *ExecutionLogMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *ExecutionLogMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldDurationMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *ExecutionLogMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *ExecutionLogMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *ExecutionLogMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[executionlog.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *ExecutionLogMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[executionlog.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *ExecutionLogMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, executionlog.FieldDurationMs)
}

// Where appends a list predicates to the ExecutionLogMutation builder.
func (m *ExecutionLogMutation) Where(ps ...predicate.ExecutionLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExecutionLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExecutionLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExecutionLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExecutionLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExecutionLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExecutionLog).
func (m *ExecutionLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExecutionLogMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.create_by != nil {
		fields = append(fields, executionlog.FieldCreateBy)
	}
	if m.create_time != nil {
		fields = append(fields, executionlog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, executionlog.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, executionlog.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, executionlog.FieldTenantID)
	}
	if m.script_id != nil {
		fields = append(fields, executionlog.FieldScriptID)
	}
	if m.script_name != nil {
		fields = append(fields, executionlog.FieldScriptName)
	}
	if m.client_id != nil {
		fields = append(fields, executionlog.FieldClientID)
	}
	if m.script_hash != nil {
		fields = append(fields, executionlog.FieldScriptHash)
	}
	if m.trigger_type != nil {
		fields = append(fields, executionlog.FieldTriggerType)
	}
	if m.status != nil {
		fields = append(fields, executionlog.FieldStatus)
	}
	if m.exit_code != nil {
		fields = append(fields, executionlog.FieldExitCode)
	}
	if m.output != nil {
		fields = append(fields, executionlog.FieldOutput)
	}
	if m.error_output != nil {
		fields = append(fields, executionlog.FieldErrorOutput)
	}
	if m.rejection_reason != nil {
		fields = append(fields, executionlog.FieldRejectionReason)
	}
	if m.started_at != nil {
		fields = append(fields, executionlog.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, executionlog.FieldCompletedAt)
	}
	if m.duration_ms != nil {
		fields = append(fields, executionlog.FieldDurationMs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExecutionLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case executionlog.FieldCreateBy:
		return m.CreateBy()
	case executionlog.FieldCreateTime:
		return m.CreateTime()
	case executionlog.FieldUpdateTime:
		return m.UpdateTime()
	case executionlog.FieldDeleteTime:
		return m.DeleteTime()
	case executionlog.FieldTenantID:
		return m.TenantID()
	case executionlog.FieldScriptID:
		return m.ScriptID()
	case executionlog.FieldScriptName:
		return m.ScriptName()
	case executionlog.FieldClientID:
		return m.ClientID()
	case executionlog.FieldScriptHash:
		return m.ScriptHash()
	case executionlog.FieldTriggerType:
		return m.TriggerType()
	case executionlog.FieldStatus:
		return m.Status()
	case executionlog.FieldExitCode:
		return m.ExitCode()
	case executionlog.FieldOutput:
		return m.Output()
	case executionlog.FieldErrorOutput:
		return m.ErrorOutput()
	case executionlog.FieldRejectionReason:
		return m.RejectionReason()
	case executionlog.FieldStartedAt:
		return m.StartedAt()
	case executionlog.FieldCompletedAt:
		return m.CompletedAt()
	case executionlog.FieldDurationMs:
		return m.DurationMs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExecutionLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case executionlog.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case executionlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case executionlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case executionlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case executionlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case executionlog.FieldScriptID:
		return m.OldScriptID(ctx)
	case executionlog.FieldScriptName:
		return m.OldScriptName(ctx)
	case executionlog.FieldClientID:
		return m.OldClientID(ctx)
	case executionlog.FieldScriptHash:
		return m.OldScriptHash(ctx)
	case executionlog.FieldTriggerType:
		return m.OldTriggerType(ctx)
	case executionlog.FieldStatus:
		return m.OldStatus(ctx)
	case executionlog.FieldExitCode:
		return m.OldExitCode(ctx)
	case executionlog.FieldOutput:
		return m.OldOutput(ctx)
	case executionlog.FieldErrorOutput:
		return m.OldErrorOutput(ctx)
	case executionlog.FieldRejectionReason:
		return m.OldRejectionReason(ctx)
	case executionlog.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case executionlog.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case executionlog.FieldDurationMs:
		return m.OldDurationMs(ctx)
	}
	return nil, fmt.Errorf("unknown ExecutionLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case executionlog.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case executionlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case executionlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case executionlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case executionlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case executionlog.FieldScriptID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptID(v)
		return nil
	case executionlog.FieldScriptName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptName(v)
		return nil
	case executionlog.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case executionlog.FieldScriptHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptHash(v)
		return nil
	case executionlog.FieldTriggerType:
		v, ok := value.(executionlog.TriggerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerType(v)
		return nil
	case executionlog.FieldStatus:
		v, ok := value.(executionlog.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case executionlog.FieldExitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitCode(v)
		return nil
	case executionlog.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case executionlog.FieldErrorOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorOutput(v)
		return nil
	case executionlog.FieldRejectionReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectionReason(v)
		return nil
	case executionlog.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case executionlog.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case executionlog.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown ExecutionLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExecutionLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, executionlog.FieldCreateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, executionlog.FieldTenantID)
	}
	if m.addexit_code != nil {
		fields = append(fields, executionlog.FieldExitCode)
	}
	if m.addduration_ms != nil {
		fields = append(fields, executionlog.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExecutionLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case executionlog.FieldCreateBy:
		return m.AddedCreateBy()
	case executionlog.FieldTenantID:
		return m.AddedTenantID()
	case executionlog.FieldExitCode:
		return m.AddedExitCode()
	case executionlog.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case executionlog.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case executionlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case executionlog.FieldExitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExitCode(v)
		return nil
	case executionlog.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown ExecutionLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExecutionLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(executionlog.FieldCreateBy) {
		fields = append(fields, executionlog.FieldCreateBy)
	}
	if m.FieldCleared(executionlog.FieldCreateTime) {
		fields = append(fields, executionlog.FieldCreateTime)
	}
	if m.FieldCleared(executionlog.FieldUpdateTime) {
		fields = append(fields, executionlog.FieldUpdateTime)
	}
	if m.FieldCleared(executionlog.FieldDeleteTime) {
		fields = append(fields, executionlog.FieldDeleteTime)
	}
	if m.FieldCleared(executionlog.FieldTenantID) {
		fields = append(fields, executionlog.FieldTenantID)
	}
	if m.FieldCleared(executionlog.FieldExitCode) {
		fields = append(fields, executionlog.FieldExitCode)
	}
	if m.FieldCleared(executionlog.FieldOutput) {
		fields = append(fields, executionlog.FieldOutput)
	}
	if m.FieldCleared(executionlog.FieldErrorOutput) {
		fields = append(fields, executionlog.FieldErrorOutput)
	}
	if m.FieldCleared(executionlog.FieldRejectionReason) {
		fields = append(fields, executionlog.FieldRejectionReason)
	}
	if m.FieldCleared(executionlog.FieldStartedAt) {
		fields = append(fields, executionlog.FieldStartedAt)
	}
	if m.FieldCleared(executionlog.FieldCompletedAt) {
		fields = append(fields, executionlog.FieldCompletedAt)
	}
	if m.FieldCleared(executionlog.FieldDurationMs) {
		fields = append(fields, executionlog.FieldDurationMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExecutionLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExecutionLogMutation) ClearField(name string) error {
	switch name {
	case executionlog.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case executionlog.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case executionlog.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case executionlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case executionlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case executionlog.FieldExitCode:
		m.ClearExitCode()
		return nil
	case executionlog.FieldOutput:
		m.ClearOutput()
		return nil
	case executionlog.FieldErrorOutput:
		m.ClearErrorOutput()
		return nil
	case executionlog.FieldRejectionReason:
		m.ClearRejectionReason()
		return nil
	case executionlog.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case executionlog.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case executionlog.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	}
	return fmt.Errorf("unknown ExecutionLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExecutionLogMutation) ResetField(name string) error {
	switch name {
	case executionlog.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case executionlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case executionlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case executionlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case executionlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case executionlog.FieldScriptID:
		m.ResetScriptID()
		return nil
	case executionlog.FieldScriptName:
		m.ResetScriptName()
		return nil
	case executionlog.FieldClientID:
		m.ResetClientID()
		return nil
	case executionlog.FieldScriptHash:
		m.ResetScriptHash()
		return nil
	case executionlog.FieldTriggerType:
		m.ResetTriggerType()
		return nil
	case executionlog.FieldStatus:
		m.ResetStatus()
		return nil
	case executionlog.FieldExitCode:
		m.ResetExitCode()
		return nil
	case executionlog.FieldOutput:
		m.ResetOutput()
		return nil
	case executionlog.FieldErrorOutput:
		m.ResetErrorOutput()
		return nil
	case executionlog.FieldRejectionReason:
		m.ResetRejectionReason()
		return nil
	case executionlog.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case executionlog.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case executionlog.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	}
	return fmt.Errorf("unknown ExecutionLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExecutionLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExecutionLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExecutionLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExecutionLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExecutionLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExecutionLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExecutionLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExecutionLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExecutionLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExecutionLog edge %s", name)
}

// ScriptMutation represents an operation that mutates the Script nodes in the graph.
type ScriptMutation struct {
	config
	op            Op
	typ           string
	id            *string
	create_by     *uint32
	addcreate_by  *int32
	update_by     *uint32
	addupdate_by  *int32
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	tenant_id     *uint32
	addtenant_id  *int32
	name          *string
	description   *string
	script_type   *script.ScriptType
	content       *string
	content_hash  *string
	version       *int
	addversion    *int
	enabled       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Script, error)
	predicates    []predicate.Script
}

var _ ent.Mutation = (*ScriptMutation)(nil)

// scriptOption allows management of the mutation configuration using functional options.
type scriptOption func(*ScriptMutation)

// newScriptMutation creates new mutation for the Script entity.
func newScriptMutation(c config, op Op, opts ...scriptOption) *ScriptMutation {
	m := &ScriptMutation{
		config:        c,
		op:            op,
		typ:           TypeScript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptID sets the ID field of the mutation.
func withScriptID(id string) scriptOption {
	return func(m *ScriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Script
		)
		m.oldValue = func(ctx context.Context) (*Script, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Script.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScript sets the old Script of the mutation.
func withScript(node *Script) scriptOption {
	return func(m *ScriptMutation) {
		m.oldValue = func(context.Context) (*Script, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Script entities.
func (m *ScriptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScriptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScriptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Script.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *ScriptMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *ScriptMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *ScriptMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *ScriptMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *ScriptMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[script.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *ScriptMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[script.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *ScriptMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, script.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *ScriptMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *ScriptMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *ScriptMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *ScriptMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *ScriptMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[script.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *ScriptMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[script.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *ScriptMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, script.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *ScriptMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScriptMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ScriptMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[script.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ScriptMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[script.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScriptMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, script.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *ScriptMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScriptMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ScriptMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[script.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ScriptMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[script.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScriptMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, script.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *ScriptMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ScriptMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ScriptMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[script.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ScriptMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[script.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ScriptMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, script.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *ScriptMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ScriptMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *ScriptMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ScriptMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ScriptMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[script.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ScriptMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[script.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ScriptMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, script.FieldTenantID)
}

// SetName sets the "name" field.
func (m *ScriptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScriptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScriptMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ScriptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScriptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ScriptMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[script.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ScriptMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[script.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ScriptMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, script.FieldDescription)
}

// SetScriptType sets the "script_type" field.
func (m *ScriptMutation) SetScriptType(st script.ScriptType) {
	m.script_type = &st
}

// ScriptType returns the value of the "script_type" field in the mutation.
func (m *ScriptMutation) ScriptType() (r script.ScriptType, exists bool) {
	v := m.script_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptType returns the old "script_type" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldScriptType(ctx context.Context) (v script.ScriptType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptType: %w", err)
	}
	return oldValue.ScriptType, nil
}

// ResetScriptType resets all changes to the "script_type" field.
func (m *ScriptMutation) ResetScriptType() {
	m.script_type = nil
}

// SetContent sets the "content" field.
func (m *ScriptMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ScriptMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ScriptMutation) ResetContent() {
	m.content = nil
}

// SetContentHash sets the "content_hash" field.
func (m *ScriptMutation) SetContentHash(s string) {
	m.content_hash = &s
}

// ContentHash returns the value of the "content_hash" field in the mutation.
func (m *ScriptMutation) ContentHash() (r string, exists bool) {
	v := m.content_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHash returns the old "content_hash" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldContentHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHash: %w", err)
	}
	return oldValue.ContentHash, nil
}

// ResetContentHash resets all changes to the "content_hash" field.
func (m *ScriptMutation) ResetContentHash() {
	m.content_hash = nil
}

// SetVersion sets the "version" field.
func (m *ScriptMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ScriptMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ScriptMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ScriptMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ScriptMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetEnabled sets the "enabled" field.
func (m *ScriptMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ScriptMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ScriptMutation) ResetEnabled() {
	m.enabled = nil
}

// Where appends a list predicates to the ScriptMutation builder.
func (m *ScriptMutation) Where(ps ...predicate.Script) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScriptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScriptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Script, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScriptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScriptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Script).
func (m *ScriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScriptMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_by != nil {
		fields = append(fields, script.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, script.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, script.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, script.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, script.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, script.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, script.FieldName)
	}
	if m.description != nil {
		fields = append(fields, script.FieldDescription)
	}
	if m.script_type != nil {
		fields = append(fields, script.FieldScriptType)
	}
	if m.content != nil {
		fields = append(fields, script.FieldContent)
	}
	if m.content_hash != nil {
		fields = append(fields, script.FieldContentHash)
	}
	if m.version != nil {
		fields = append(fields, script.FieldVersion)
	}
	if m.enabled != nil {
		fields = append(fields, script.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case script.FieldCreateBy:
		return m.CreateBy()
	case script.FieldUpdateBy:
		return m.UpdateBy()
	case script.FieldCreateTime:
		return m.CreateTime()
	case script.FieldUpdateTime:
		return m.UpdateTime()
	case script.FieldDeleteTime:
		return m.DeleteTime()
	case script.FieldTenantID:
		return m.TenantID()
	case script.FieldName:
		return m.Name()
	case script.FieldDescription:
		return m.Description()
	case script.FieldScriptType:
		return m.ScriptType()
	case script.FieldContent:
		return m.Content()
	case script.FieldContentHash:
		return m.ContentHash()
	case script.FieldVersion:
		return m.Version()
	case script.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case script.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case script.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case script.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case script.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case script.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case script.FieldTenantID:
		return m.OldTenantID(ctx)
	case script.FieldName:
		return m.OldName(ctx)
	case script.FieldDescription:
		return m.OldDescription(ctx)
	case script.FieldScriptType:
		return m.OldScriptType(ctx)
	case script.FieldContent:
		return m.OldContent(ctx)
	case script.FieldContentHash:
		return m.OldContentHash(ctx)
	case script.FieldVersion:
		return m.OldVersion(ctx)
	case script.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown Script field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case script.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case script.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case script.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case script.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case script.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case script.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case script.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case script.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case script.FieldScriptType:
		v, ok := value.(script.ScriptType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptType(v)
		return nil
	case script.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case script.FieldContentHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHash(v)
		return nil
	case script.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case script.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScriptMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, script.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, script.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, script.FieldTenantID)
	}
	if m.addversion != nil {
		fields = append(fields, script.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case script.FieldCreateBy:
		return m.AddedCreateBy()
	case script.FieldUpdateBy:
		return m.AddedUpdateBy()
	case script.FieldTenantID:
		return m.AddedTenantID()
	case script.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case script.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case script.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case script.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case script.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Script numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScriptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(script.FieldCreateBy) {
		fields = append(fields, script.FieldCreateBy)
	}
	if m.FieldCleared(script.FieldUpdateBy) {
		fields = append(fields, script.FieldUpdateBy)
	}
	if m.FieldCleared(script.FieldCreateTime) {
		fields = append(fields, script.FieldCreateTime)
	}
	if m.FieldCleared(script.FieldUpdateTime) {
		fields = append(fields, script.FieldUpdateTime)
	}
	if m.FieldCleared(script.FieldDeleteTime) {
		fields = append(fields, script.FieldDeleteTime)
	}
	if m.FieldCleared(script.FieldTenantID) {
		fields = append(fields, script.FieldTenantID)
	}
	if m.FieldCleared(script.FieldDescription) {
		fields = append(fields, script.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptMutation) ClearField(name string) error {
	switch name {
	case script.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case script.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case script.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case script.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case script.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case script.FieldTenantID:
		m.ClearTenantID()
		return nil
	case script.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Script nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScriptMutation) ResetField(name string) error {
	switch name {
	case script.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case script.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case script.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case script.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case script.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case script.FieldTenantID:
		m.ResetTenantID()
		return nil
	case script.FieldName:
		m.ResetName()
		return nil
	case script.FieldDescription:
		m.ResetDescription()
		return nil
	case script.FieldScriptType:
		m.ResetScriptType()
		return nil
	case script.FieldContent:
		m.ResetContent()
		return nil
	case script.FieldContentHash:
		m.ResetContentHash()
		return nil
	case script.FieldVersion:
		m.ResetVersion()
		return nil
	case script.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScriptMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScriptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScriptMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScriptMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Script unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScriptMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Script edge %s", name)
}

// ScriptAssignmentMutation represents an operation that mutates the ScriptAssignment nodes in the graph.
type ScriptAssignmentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	create_by     *uint32
	addcreate_by  *int32
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	tenant_id     *uint32
	addtenant_id  *int32
	script_id     *string
	client_id     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ScriptAssignment, error)
	predicates    []predicate.ScriptAssignment
}

var _ ent.Mutation = (*ScriptAssignmentMutation)(nil)

// scriptassignmentOption allows management of the mutation configuration using functional options.
type scriptassignmentOption func(*ScriptAssignmentMutation)

// newScriptAssignmentMutation creates new mutation for the ScriptAssignment entity.
func newScriptAssignmentMutation(c config, op Op, opts ...scriptassignmentOption) *ScriptAssignmentMutation {
	m := &ScriptAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeScriptAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptAssignmentID sets the ID field of the mutation.
func withScriptAssignmentID(id string) scriptassignmentOption {
	return func(m *ScriptAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *ScriptAssignment
		)
		m.oldValue = func(ctx context.Context) (*ScriptAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScriptAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScriptAssignment sets the old ScriptAssignment of the mutation.
func withScriptAssignment(node *ScriptAssignment) scriptassignmentOption {
	return func(m *ScriptAssignmentMutation) {
		m.oldValue = func(context.Context) (*ScriptAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScriptAssignment entities.
func (m *ScriptAssignmentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScriptAssignmentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScriptAssignmentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScriptAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *ScriptAssignmentMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *ScriptAssignmentMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the ScriptAssignment entity.
// If the ScriptAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptAssignmentMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *ScriptAssignmentMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *ScriptAssignmentMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *ScriptAssignmentMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[scriptassignment.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *ScriptAssignmentMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[scriptassignment.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *ScriptAssignmentMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, scriptassignment.FieldCreateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *ScriptAssignmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScriptAssignmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ScriptAssignment entity.
// If the ScriptAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptAssignmentMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ScriptAssignmentMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[scriptassignment.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ScriptAssignmentMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[scriptassignment.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScriptAssignmentMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, scriptassignment.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *ScriptAssignmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScriptAssignmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ScriptAssignment entity.
// If the ScriptAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptAssignmentMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ScriptAssignmentMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[scriptassignment.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ScriptAssignmentMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[scriptassignment.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScriptAssignmentMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, scriptassignment.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *ScriptAssignmentMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ScriptAssignmentMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the ScriptAssignment entity.
// If the ScriptAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptAssignmentMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ScriptAssignmentMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[scriptassignment.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ScriptAssignmentMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[scriptassignment.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ScriptAssignmentMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, scriptassignment.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *ScriptAssignmentMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ScriptAssignmentMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ScriptAssignment entity.
// If the ScriptAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptAssignmentMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *ScriptAssignmentMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ScriptAssignmentMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ScriptAssignmentMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[scriptassignment.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ScriptAssignmentMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[scriptassignment.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ScriptAssignmentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, scriptassignment.FieldTenantID)
}

// SetScriptID sets the "script_id" field.
func (m *ScriptAssignmentMutation) SetScriptID(s string) {
	m.script_id = &s
}

// ScriptID returns the value of the "script_id" field in the mutation.
func (m *ScriptAssignmentMutation) ScriptID() (r string, exists bool) {
	v := m.script_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptID returns the old "script_id" field's value of the ScriptAssignment entity.
// If the ScriptAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptAssignmentMutation) OldScriptID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptID: %w", err)
	}
	return oldValue.ScriptID, nil
}

// ResetScriptID resets all changes to the "script_id" field.
func (m *ScriptAssignmentMutation) ResetScriptID() {
	m.script_id = nil
}

// SetClientID sets the "client_id" field.
func (m *ScriptAssignmentMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *ScriptAssignmentMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the ScriptAssignment entity.
// If the ScriptAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptAssignmentMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *ScriptAssignmentMutation) ResetClientID() {
	m.client_id = nil
}

// Where appends a list predicates to the ScriptAssignmentMutation builder.
func (m *ScriptAssignmentMutation) Where(ps ...predicate.ScriptAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScriptAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScriptAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScriptAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScriptAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScriptAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScriptAssignment).
func (m *ScriptAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScriptAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_by != nil {
		fields = append(fields, scriptassignment.FieldCreateBy)
	}
	if m.create_time != nil {
		fields = append(fields, scriptassignment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, scriptassignment.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, scriptassignment.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, scriptassignment.FieldTenantID)
	}
	if m.script_id != nil {
		fields = append(fields, scriptassignment.FieldScriptID)
	}
	if m.client_id != nil {
		fields = append(fields, scriptassignment.FieldClientID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScriptAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scriptassignment.FieldCreateBy:
		return m.CreateBy()
	case scriptassignment.FieldCreateTime:
		return m.CreateTime()
	case scriptassignment.FieldUpdateTime:
		return m.UpdateTime()
	case scriptassignment.FieldDeleteTime:
		return m.DeleteTime()
	case scriptassignment.FieldTenantID:
		return m.TenantID()
	case scriptassignment.FieldScriptID:
		return m.ScriptID()
	case scriptassignment.FieldClientID:
		return m.ClientID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScriptAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scriptassignment.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case scriptassignment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case scriptassignment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case scriptassignment.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case scriptassignment.FieldTenantID:
		return m.OldTenantID(ctx)
	case scriptassignment.FieldScriptID:
		return m.OldScriptID(ctx)
	case scriptassignment.FieldClientID:
		return m.OldClientID(ctx)
	}
	return nil, fmt.Errorf("unknown ScriptAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scriptassignment.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case scriptassignment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case scriptassignment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case scriptassignment.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case scriptassignment.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case scriptassignment.FieldScriptID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptID(v)
		return nil
	case scriptassignment.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	}
	return fmt.Errorf("unknown ScriptAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScriptAssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, scriptassignment.FieldCreateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, scriptassignment.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScriptAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scriptassignment.FieldCreateBy:
		return m.AddedCreateBy()
	case scriptassignment.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scriptassignment.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case scriptassignment.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ScriptAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScriptAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scriptassignment.FieldCreateBy) {
		fields = append(fields, scriptassignment.FieldCreateBy)
	}
	if m.FieldCleared(scriptassignment.FieldCreateTime) {
		fields = append(fields, scriptassignment.FieldCreateTime)
	}
	if m.FieldCleared(scriptassignment.FieldUpdateTime) {
		fields = append(fields, scriptassignment.FieldUpdateTime)
	}
	if m.FieldCleared(scriptassignment.FieldDeleteTime) {
		fields = append(fields, scriptassignment.FieldDeleteTime)
	}
	if m.FieldCleared(scriptassignment.FieldTenantID) {
		fields = append(fields, scriptassignment.FieldTenantID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScriptAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptAssignmentMutation) ClearField(name string) error {
	switch name {
	case scriptassignment.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case scriptassignment.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case scriptassignment.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case scriptassignment.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case scriptassignment.FieldTenantID:
		m.ClearTenantID()
		return nil
	}
	return fmt.Errorf("unknown ScriptAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScriptAssignmentMutation) ResetField(name string) error {
	switch name {
	case scriptassignment.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case scriptassignment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case scriptassignment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case scriptassignment.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case scriptassignment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case scriptassignment.FieldScriptID:
		m.ResetScriptID()
		return nil
	case scriptassignment.FieldClientID:
		m.ResetClientID()
		return nil
	}
	return fmt.Errorf("unknown ScriptAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScriptAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScriptAssignmentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScriptAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScriptAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScriptAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScriptAssignmentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScriptAssignmentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ScriptAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScriptAssignmentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ScriptAssignment edge %s", name)
}
