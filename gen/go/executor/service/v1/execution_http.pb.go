// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             (unknown)
// source: executor/service/v1/execution.proto

package executorpb

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationExecutorExecutionServiceGetExecution = "/executor.service.v1.ExecutorExecutionService/GetExecution"
const OperationExecutorExecutionServiceGetExecutionOutput = "/executor.service.v1.ExecutorExecutionService/GetExecutionOutput"
const OperationExecutorExecutionServiceListConnectedClients = "/executor.service.v1.ExecutorExecutionService/ListConnectedClients"
const OperationExecutorExecutionServiceListExecutions = "/executor.service.v1.ExecutorExecutionService/ListExecutions"
const OperationExecutorExecutionServiceTriggerClientUpdate = "/executor.service.v1.ExecutorExecutionService/TriggerClientUpdate"
const OperationExecutorExecutionServiceTriggerExecution = "/executor.service.v1.ExecutorExecutionService/TriggerExecution"

type ExecutorExecutionServiceHTTPServer interface {
	// GetExecution Get execution details
	GetExecution(context.Context, *GetExecutionRequest) (*GetExecutionResponse, error)
	// GetExecutionOutput Get execution output (full stdout/stderr)
	GetExecutionOutput(context.Context, *GetExecutionOutputRequest) (*GetExecutionOutputResponse, error)
	// ListConnectedClients List currently connected clients with their versions
	ListConnectedClients(context.Context, *ListConnectedClientsRequest) (*ListConnectedClientsResponse, error)
	// ListExecutions List executions
	ListExecutions(context.Context, *ListExecutionsRequest) (*ListExecutionsResponse, error)
	// TriggerClientUpdate Trigger a client self-update via the command stream
	TriggerClientUpdate(context.Context, *TriggerClientUpdateRequest) (*TriggerClientUpdateResponse, error)
	// TriggerExecution Trigger script execution on a client (UI-push)
	TriggerExecution(context.Context, *TriggerExecutionRequest) (*TriggerExecutionResponse, error)
}

func RegisterExecutorExecutionServiceHTTPServer(s *http.Server, srv ExecutorExecutionServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/scripts/{script_id}/execute", _ExecutorExecutionService_TriggerExecution0_HTTP_Handler(srv))
	r.GET("/v1/executions/{id}", _ExecutorExecutionService_GetExecution0_HTTP_Handler(srv))
	r.GET("/v1/executions", _ExecutorExecutionService_ListExecutions0_HTTP_Handler(srv))
	r.GET("/v1/executions/{id}/output", _ExecutorExecutionService_GetExecutionOutput0_HTTP_Handler(srv))
	r.POST("/v1/clients/{client_id}/update", _ExecutorExecutionService_TriggerClientUpdate0_HTTP_Handler(srv))
	r.GET("/v1/clients/connected", _ExecutorExecutionService_ListConnectedClients0_HTTP_Handler(srv))
}

func _ExecutorExecutionService_TriggerExecution0_HTTP_Handler(srv ExecutorExecutionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TriggerExecutionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationExecutorExecutionServiceTriggerExecution)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TriggerExecution(ctx, req.(*TriggerExecutionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TriggerExecutionResponse)
		return ctx.Result(200, reply)
	}
}

func _ExecutorExecutionService_GetExecution0_HTTP_Handler(srv ExecutorExecutionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetExecutionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationExecutorExecutionServiceGetExecution)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetExecution(ctx, req.(*GetExecutionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetExecutionResponse)
		return ctx.Result(200, reply)
	}
}

func _ExecutorExecutionService_ListExecutions0_HTTP_Handler(srv ExecutorExecutionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListExecutionsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationExecutorExecutionServiceListExecutions)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListExecutions(ctx, req.(*ListExecutionsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListExecutionsResponse)
		return ctx.Result(200, reply)
	}
}

func _ExecutorExecutionService_GetExecutionOutput0_HTTP_Handler(srv ExecutorExecutionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetExecutionOutputRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationExecutorExecutionServiceGetExecutionOutput)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetExecutionOutput(ctx, req.(*GetExecutionOutputRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetExecutionOutputResponse)
		return ctx.Result(200, reply)
	}
}

func _ExecutorExecutionService_TriggerClientUpdate0_HTTP_Handler(srv ExecutorExecutionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TriggerClientUpdateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationExecutorExecutionServiceTriggerClientUpdate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TriggerClientUpdate(ctx, req.(*TriggerClientUpdateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TriggerClientUpdateResponse)
		return ctx.Result(200, reply)
	}
}

func _ExecutorExecutionService_ListConnectedClients0_HTTP_Handler(srv ExecutorExecutionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListConnectedClientsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationExecutorExecutionServiceListConnectedClients)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListConnectedClients(ctx, req.(*ListConnectedClientsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListConnectedClientsResponse)
		return ctx.Result(200, reply)
	}
}

type ExecutorExecutionServiceHTTPClient interface {
	// GetExecution Get execution details
	GetExecution(ctx context.Context, req *GetExecutionRequest, opts ...http.CallOption) (rsp *GetExecutionResponse, err error)
	// GetExecutionOutput Get execution output (full stdout/stderr)
	GetExecutionOutput(ctx context.Context, req *GetExecutionOutputRequest, opts ...http.CallOption) (rsp *GetExecutionOutputResponse, err error)
	// ListConnectedClients List currently connected clients with their versions
	ListConnectedClients(ctx context.Context, req *ListConnectedClientsRequest, opts ...http.CallOption) (rsp *ListConnectedClientsResponse, err error)
	// ListExecutions List executions
	ListExecutions(ctx context.Context, req *ListExecutionsRequest, opts ...http.CallOption) (rsp *ListExecutionsResponse, err error)
	// TriggerClientUpdate Trigger a client self-update via the command stream
	TriggerClientUpdate(ctx context.Context, req *TriggerClientUpdateRequest, opts ...http.CallOption) (rsp *TriggerClientUpdateResponse, err error)
	// TriggerExecution Trigger script execution on a client (UI-push)
	TriggerExecution(ctx context.Context, req *TriggerExecutionRequest, opts ...http.CallOption) (rsp *TriggerExecutionResponse, err error)
}

type ExecutorExecutionServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewExecutorExecutionServiceHTTPClient(client *http.Client) ExecutorExecutionServiceHTTPClient {
	return &ExecutorExecutionServiceHTTPClientImpl{client}
}

// GetExecution Get execution details
func (c *ExecutorExecutionServiceHTTPClientImpl) GetExecution(ctx context.Context, in *GetExecutionRequest, opts ...http.CallOption) (*GetExecutionResponse, error) {
	var out GetExecutionResponse
	pattern := "/v1/executions/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationExecutorExecutionServiceGetExecution))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetExecutionOutput Get execution output (full stdout/stderr)
func (c *ExecutorExecutionServiceHTTPClientImpl) GetExecutionOutput(ctx context.Context, in *GetExecutionOutputRequest, opts ...http.CallOption) (*GetExecutionOutputResponse, error) {
	var out GetExecutionOutputResponse
	pattern := "/v1/executions/{id}/output"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationExecutorExecutionServiceGetExecutionOutput))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListConnectedClients List currently connected clients with their versions
func (c *ExecutorExecutionServiceHTTPClientImpl) ListConnectedClients(ctx context.Context, in *ListConnectedClientsRequest, opts ...http.CallOption) (*ListConnectedClientsResponse, error) {
	var out ListConnectedClientsResponse
	pattern := "/v1/clients/connected"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationExecutorExecutionServiceListConnectedClients))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListExecutions List executions
func (c *ExecutorExecutionServiceHTTPClientImpl) ListExecutions(ctx context.Context, in *ListExecutionsRequest, opts ...http.CallOption) (*ListExecutionsResponse, error) {
	var out ListExecutionsResponse
	pattern := "/v1/executions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationExecutorExecutionServiceListExecutions))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// TriggerClientUpdate Trigger a client self-update via the command stream
func (c *ExecutorExecutionServiceHTTPClientImpl) TriggerClientUpdate(ctx context.Context, in *TriggerClientUpdateRequest, opts ...http.CallOption) (*TriggerClientUpdateResponse, error) {
	var out TriggerClientUpdateResponse
	pattern := "/v1/clients/{client_id}/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationExecutorExecutionServiceTriggerClientUpdate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// TriggerExecution Trigger script execution on a client (UI-push)
func (c *ExecutorExecutionServiceHTTPClientImpl) TriggerExecution(ctx context.Context, in *TriggerExecutionRequest, opts ...http.CallOption) (*TriggerExecutionResponse, error) {
	var out TriggerExecutionResponse
	pattern := "/v1/scripts/{script_id}/execute"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationExecutorExecutionServiceTriggerExecution))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
